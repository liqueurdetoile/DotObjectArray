<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ObjectArray.html">ObjectArray</a><ul class='methods'><li data-type='method'><a href="ObjectArray.html#~camelize">camelize</a></li><li data-type='method'><a href="ObjectArray.html#~childKey">childKey</a></li><li data-type='method'><a href="ObjectArray.html#~clone">clone</a></li><li data-type='method'><a href="ObjectArray.html#~dashize">dashize</a></li><li data-type='method'><a href="ObjectArray.html#~dataset">dataset</a></li><li data-type='method'><a href="ObjectArray.html#~empty">empty</a></li><li data-type='method'><a href="ObjectArray.html#~flatten">flatten</a></li><li data-type='method'><a href="ObjectArray.html#~forEach">forEach</a></li><li data-type='method'><a href="ObjectArray.html#~formUrlEncode">formUrlEncode</a></li><li data-type='method'><a href="ObjectArray.html#~has">has</a></li><li data-type='method'><a href="ObjectArray.html#~import">import</a></li><li data-type='method'><a href="ObjectArray.html#~keys">keys</a></li><li data-type='method'><a href="ObjectArray.html#~length">length</a></li><li data-type='method'><a href="ObjectArray.html#~parentKey">parentKey</a></li><li data-type='method'><a href="ObjectArray.html#~push">push</a></li><li data-type='method'><a href="ObjectArray.html#~reduce">reduce</a></li><li data-type='method'><a href="ObjectArray.html#~remove">remove</a></li><li data-type='method'><a href="ObjectArray.html#~stringToStyles">stringToStyles</a></li><li data-type='method'><a href="ObjectArray.html#~stylesToString">stylesToString</a></li><li data-type='method'><a href="ObjectArray.html#~urlEncode">urlEncode</a></li><li data-type='method'><a href="ObjectArray.html#~values">values</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
*  @file ObjectArray class declaration
*  @author  Liqueur de Toile &lt;contact@liqueurdetoile.com>
*  @license MIT {@link https://choosealicense.com/licenses/mit/}
*  @see [Github]{@link https://github.com/liqueurdetoile/objectarray}
*  @see [Author website]{@link https://liqueurdetoile.com}
*/

/**
*  @classDesc
*  The ObjectArray class implements array-like properties and
*  methods to a key/value javascript object.
*  It can be viewed as a kind of associative array in JS but it also
*  supports dot notation keys.
*
*  @class ObjectArray
*  @since 1.0.0
*  @version 1.0.0
*  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
*  @license MIT {@link https://choosealicense.com/licenses/mit/}
*  @see [Github]{@link https://github.com/liqueurdetoile/objectarray}
*  @see [Author website]{@link https://liqueurdetoile.com}
*
*  @param   {Object}    data  Initial data to push into the ObjectArray
*
*  @returns {ObjectArray} ObjectArray object
*  @description
*  The constructor is straight-forward. It can be provided with an existent object
*/

export default class ObjectArray {
  constructor(data = {}) {
    /**
    *  The inner data object
    *
    *  @alias ObjectArray~_data
    *  @private
    *  @type {Object}
    *  @since 1.0.0
    */
    this._data = {};
    this.import(data);
  }

  /**
  *  Getter/setter for the root data of ObjectArray.
  *
  *  @alias ObjectArray~data
  *  @type  Object
  *  @since 1.0.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  */
  get data() {
    return this._data;
  }

  set data(data) {
    this.import(data);
  }

  /**
  *  Returns a clone with same data of the current ObjectArray
  *
  *  @method ObjectArray~clone
  *  @since 1.3.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {Boolean} [keepFlattened=true]
  *  If true, the flattened dotted keys will remains flattened
  *  otherwise, the full hierarchy will be restored
  *  @returns {ObjectArray} Return cloned ObjectArray
  */
  clone(keepFlattened = true) {
    let o = new ObjectArray();

    if (keepFlattened) o._data = this._data;
    else o.import(this._data);
    return o;
  }

  /**
  *  Empty the ObjectArray data. It can also be used as
  *  an alias for [remove method]{@link ObjectArray~remove}
  *
  *  @method ObjectArray~empty
  *  @since 1.2.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey} Key  Key to remove
  *  @returns {ObjectArray} Return self for chaining
  */
  empty(key) {
    if (typeof key === 'undefined') this._data = {};
    else this.remove(key);
    return this;
  }

  /**
  *  Returns length of a given dataset in the ObjectArray
  *  If no parent key is provided, it will output the length of
  *  the root data object
  *
  *  @method ObjectArray~length
  *  @since 1.0.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey} pKey  Parent key
  *  @returns  {Number|undefined} Length of the dataset or undefined if key doesn't exist
  */
  length(pKey) {
    let data = this.keys(pKey);

    if (!data) return undefined;
    return this.keys(pKey).length;
  }

  /**
  *  Returns keys of a given dataset in the ObjectArray
  *  If no parent key is provided, it will output the keys of
  *  the root data object
  *
  *  @method ObjectArray~keys
  *  @since 1.0.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey} pKey  Parent key
  *  @returns  {Array|undefined} Array of keys for the dataset
  *  or undefined if key doesn't exist
  */
  keys(pKey) {
    let keys = [], data = this.dataset(pKey);

    if (!data) return undefined;
    for (let key in data) keys.push(key);
    return keys;
  }

  /**
  *  Returns values of a given dataset in the ObjectArray
  *  If no parent key is provided, it will output the keys of
  *  the root data object
  *
  *  @method ObjectArray~values
  *  @since 1.0.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey} pKey  Parent key
  *  @returns  {Array|undefined} Array of values for the dataset
  *  or undefined if key doesn't exist
  */
  values(pKey) {
    let values = [], data = this.dataset(pKey);

    if (!data) return undefined;
    for (let key in data) values.push(data[key]);
    return values;
  }

  /**
  *  Check if a given key exists in the ObjectArray
  *
  *  @method ObjectArray~has
  *  @since 1.0.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey}  key Key
  *  @returns {Boolean}  true if key exists, false otherwise
  */
  has(key) {
    let i, k, data = this.data;

    if (typeof key === 'undefined') return false;

    key = key.split('.');
    for (i = 0; i &lt; key.length; i++) {
      k = key[i];

      if (typeof data[k] === 'undefined') return false;
      data = data[k];
    }
    return true;
  }

  /**
  *  Returns dataset for the key. If no key is provided,
  *  the whole data is returned
  *
  *  @method ObjectArray~dataset
  *  @since 1.0.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey}  [key=null] Key
  *  @returns {Object|undefined} Data object or undefined if key doesn't exist
  */
  dataset(key) {
    let i, k, data = this.data;

    if (key !== undefined) {
      key = key.split('.');
      for (i = 0; i &lt; key.length; i++) {
        k = key[i];

        if (typeof data[k] === 'undefined') return undefined;
        data = data[k];
      }
    }
    return data;
  }

  /**
  *  Returns the parent key for a given key
  *
  *  @method ObjectArray~parentKey
  *  @since 1.0.0
  *  @version 1.0.1
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey}  key Key
  *  @returns {String} Parent key
  */
  parentKey(key) {
    if (typeof key !== 'undefined') {
      key = key.split('.');
      key.pop();

      if (key.length) {
        key = key.join('.');
        return key;
      }
    }
    return undefined;
  }

  /**
  *  Returns the child key for a given key
  *
  *  @method ObjectArray~childKey
  *  @since 1.3.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey}  key Key
  *  @returns {String}  Child key
  */
  childKey(key) {
    if (typeof key !== 'undefined') {
      key = key.split('.');
      key.shift();

      if (key.length) {
        key = key.join('.');
        return key;
      }
    }
    return undefined;
  }

  /**
  *  Private method to recurse flatten
  *
  *  @method ObjectArray~_recurseFlatten
  *  @private
  *  @since 1.3.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {Object}    ret     Object to complete
  *  @param {Boolean}   dotted  Should the new key be dotted or not
  *  @param {dottedKey} pKey    Parent key defining current subdataset
  *  @returns {Object}  Completed result with non-object data
  */
  _recurseFlatten(ret, dotted, pKey) {
    let k, data = this.dataset(pKey);

    for (let key in data) {
      if (typeof data[key] === 'object') this._recurseFlatten(ret, dotted, pKey ? pKey + '.' + key : key);
      else {
        // Correct key for root key or subdataset key
        pKey = (this.childKey(pKey)) ? this.childKey(pKey) : pKey;
        k = (dotted &amp;&amp; pKey) ? pKey + '.' + key : key;
        ret[k] = data[key];
      }
    }
    return ret;
  }

  /**
  *  Flattens the object and replace data.
  *
  *  Each object in the dataset is
  *  recursively explored to extract data and bring it a top level.
  *
  *  With default behaviour, if two or more properties have same name under
  *  subkeys, the last explored one will replace the previous one.
  *
  *  If the method is called with &lt;tt>true&lt;/tt> as first parameter, the
  *  resulting data keys will be dotted, preventing duplication. In that case,
  *  you must access new keys with &lt;tt>dataset&lt;/tt> method or by calling
  *  the &lt;tt>data&lt;/tt> key property with [] (e.g. doa.data['my.key']);
  *
  *  Flatten can be run only on a subdataset by providing a key as second parameter.
  *
  *  @method ObjectArray~flatten
  *  @since 1.3.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {Boolean} [dotted = false]
  *  @param {dottedKey}  [pKey]  Key to flatten. If not provided, the whole
  *  dataset will flattened.
  *  @returns {Boolean} Parent key
  */
  flatten(dotted = false, pKey) {
    let data;

    if (typeof pKey === 'undefined') data = this._recurseFlatten({}, dotted);
    else if (this.has(pKey)) data = this._recurseFlatten({}, dotted, pKey);
    else return this;

    if (typeof pKey === 'undefined') this._data = data;
    else this.push(pKey, data);
    return this;
  }

  /**
  *  Push a new key/value pair
  *
  *  @method ObjectArray~push
  *  @since 1.0.0
  *  @version 1.1.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey} key Key of the added item
  *  @param {Number|String|Array|Object} val Value of the added item
  *  @param {dottedKey}  [pKey]  Parent key to push into
  *  @returns {ObjectArray} Return self for chaining
  */
  push(key, val, pKey) {
    let k, data;

    // Check pKey existence
    if (this.has(pKey) || typeof pKey === 'undefined') {
      data = this.dataset(pKey);
    } else {
      key = pKey + '.' + key;
      data = this.data;
    }

    key = key.split('.');
    k = key.pop();
    key.forEach(function (k, i) {
      if (typeof data[k] === 'undefined') data[k] = {};
      data = data[k];
    });
    if (val instanceof ObjectArray) val = val._data;
    data[k] = val;
    return this;
  }

  /**
  *  Remove key/value pair
  *
  *  @method ObjectArray~remove
  *  @since 1.0.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey} key Key of the added item
  *  @returns {ObjectArray} Return self for chaining
  */
  remove(key) {
    let pKey = this.parentKey(key);
    let data = this.dataset(pKey);

    if (data) {
      key = key.replace(pKey + '.', '');
      delete data[key];
    }
    return this;
  }

  /**
  *  Import an object as data into the ObjectArray
  *
  *  @method ObjectArray~import
  *  @since 1.0.0
  *  @version 1.1.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {Object} Data Object to import
  *  @param {dottedKey}  [pKey]  Dotted parent key to import into
  *  @returns {ObjectArray} Return self for chaining
  */
  import(data, pKey) {
    if (data instanceof ObjectArray) data = data._data;
    for (let key in data) this.push(key, data[key], pKey);
    return this;
  }

  /**
  *  Runs a callback on each ObjectArray entry
  *
  *  @method ObjectArray~forEach
  *  @since 1.0.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {forEachCallback} cb Callback to be run
  *  @param {dottedKey}  [key]  Dotted key to limit iterations through its subset
  *  if empty, the global data object will be used
  *  @returns {void}
  */
  forEach(cb, key) {
    let data = this.dataset(key);
    let index = 0;

    for (let key in data) cb.call(this, data[key], key, index++);
  }

  /**
  *  Reduce the ObjectArray data given a callback
  *
  *  @method ObjectArray~reduce
  *  @since 1.0.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param   {Callback}  reducer   Callback to apply to each key/value (from left)
  *  @param   {Mixed}     [start]   Initial value for iteration
  *  @param {dottedKey}  [key]  Dotted key to limit iterations through its subset
  *  if empty, the global data object will be used
  *  @returns {Mixed}               Callback returns value
  */
  reduce(reducer, start, key) {
    var acc = start;

    this.forEach(function (value, k) { acc = reducer(acc, value, k); }, key);
    return acc;
  }

  /**
  *  Returns a string suitable for a &lt;tt>style&lt;/tt> attribute.
  *  ObjectArray will convert camel-cased key to dashed key.
  *
  *  @method ObjectArray~stylesToString
  *  @since 1.0.0
  *  @version 1.1.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey}  [key]  Dotted key to limit iterations through its subset
  *  if empty, the global data object will be used
  *  @returns {String}  style string
  */
  stylesToString(key) {
    let ret = this.reduce(function (str, value, k) {
      str += this.dashize(k) + ':' + value + ';';
      return str;
    }.bind(this), '', key);

    return ret.substr(0, ret.length - 1);
  }

  /**
  *  Imports a string from a &lt;tt>style&lt;/tt> attribute.
  *  ObjectArray will camelize key from spaces and/or dashes
  *
  *  @method ObjectArray~stringToStyles
  *  @since 1.2.0
  *  @version 1.0.2
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {String}  str   String to import
  *  @param {dottedKey}  [pkey]  Dotted key to import styles into.
  *  If omitted, the object will be available at top-level
  *  @returns {ObjectArray}  Returns self for chaining
  */
  stringToStyles(str, pKey) {
    let styles = str.split(';');

    styles.forEach(function (style) {
      let parts;

      if (style !== '') { // Fix trailing ;
        parts = style.split(':');
        try {
          this.push(this.camelize(parts[0].trim()), parts[1].trim(), pKey);
        } catch (e) {
          throw new TypeError('Malformed string for stringToStyles');
        }
      }
    }.bind(this));
    return this;
  }

  /**
  *  Returns a string suitable for a URI query string
  *
  *  @method ObjectArray~urlEncode
  *  @since 1.0.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey}  [key]  Dotted key to limit iterations through its subset
  *  if empty, the global data object will be used
  *  @returns {String}  style string
  */
  urlEncode(key) {
    let ret = this.reduce(function (str, value, key) {
      str += key + '=' + encodeURIComponent(value) + '&amp;';
      return str;
    }, '', key);

    return ret.substr(0, ret.length - 1);
  }

  /**
  *  Returns a string suitable for a &lt;tt>form-url-encoded&lt;/tt> query string
  *
  *  @method ObjectArray~formUrlEncode
  *  @since 1.0.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {dottedKey}  [key]  Dotted key to limit iterations through its subset
  *  if empty, the global data object will be used
  *  @returns {String}  style string
  */
  formUrlEncode(key) {
    let ret = this.urlEncode(key);

    return ret.replace('%20', '+');
  }

  /**
  *  Returns a camelized string (without uppercase leading character)
  *  Replace dashes and spaces
  *
  *  @method ObjectArray~camelize
  *  @since 1.2.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {String}  s  String to camelize
  *  @returns {String}  Camelized string
  */
  camelize(s) {
    return s.replace(/[- ]([A-Za-z])/g, m => m[1].toUpperCase());
  }

  /**
  *  Returns a dashed string
  *  Replace Uppercases and spaces
  *
  *  @method ObjectArray~dashize
  *  @since 1.2.0
  *  @version 1.0.0
  *  @author Liqueur de Toile &lt;contact@liqueurdetoile.com>
  *
  *  @param {String}  [s]  String to dashize
  *  @returns {String}  Dashed string
  */
  dashize(s) {
    return s
      .replace(/[A-Z]/g, (m, o) => (o > 0 ? '-' : '') + m.toLowerCase())
      .replace(/ /g, (m, o, s) => s[o + 1] === '-' ? '' : '-');
  }
}

if (window) window.ObjectArray = ObjectArray;

/**
*  @typedef dottedKey
*  @type String
*  @description
*  A dotted key is useful to quickly access a subset of data
*  stored into the ObjectArray as if it was still a
*  vanilla &lt;tt>Object&lt;/tt>.
*  @example
*  // Create an ObjectArray with subdata
*  var oa = new ObjectArray({
*    set1: {
*      subset1: 'foo',
*      subset2: {
*        subsub1: 'bar',
*        subsub2: 'baz'
*      }
*    }
*  });
*  // 'set1.subset1' will yield to 'foo'
*  // 'set1.subset1.subsub2' will yield to 'baz'
*
*/
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Feb 20 2018 17:29:08 GMT+0100 (Paris, Madrid) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
